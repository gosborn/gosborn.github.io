<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Greg Osborn]]></title>
  <link href="http://gosborn.github.io/atom.xml" rel="self"/>
  <link href="http://gosborn.github.io/"/>
  <updated>2015-07-17T09:24:58-04:00</updated>
  <id>http://gosborn.github.io/</id>
  <author>
    <name><![CDATA[Greg Osborn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Working with errors in Ruby: begin, rescue and ensure]]></title>
    <link href="http://gosborn.github.io/blog/2015/07/17/working-with-errors-in-ruby-catch-and-throw/"/>
    <updated>2015-07-17T08:55:08-04:00</updated>
    <id>http://gosborn.github.io/blog/2015/07/17/working-with-errors-in-ruby-catch-and-throw</id>
    <content type="html"><![CDATA[<p>Seeing Ruby throw an exception when you don&rsquo;t expect it can be pretty frusturating. At this point in my programming career, most of them are user created. Ruby raises pretty specific exceptions and even a backtrace to figure out where you went wrong. Usually my protocol is to do find the error, figure out where my logic or typing went wrong and restart my program.</p>

<p>But sometimes exceptions arise in your program and they&rsquo;re not your fault. Lately, I&rsquo;ve been working on a database of beer that is populated with information from an online database, <a href="http://www.brewerydb.com/">breweryDB</a>. To gather the info, I&rsquo;m getting JSON files from their API with a method like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def load_db_json(input)
</span><span class='line'>  JSON.load(RestClient.get("http://api.brewerydb.com/v2/" + input)
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<p>Specifically, I&rsquo;m downloading JSON files that provide me ids to find all the beers from a group of breweries.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def all_beers_from_brewery(brewery)
</span><span class='line'>  load_db_json("brewery/#{brewery.db_code}/beers?key=#{@key}")["data"]
</span><span class='line'>end
</span><span class='line'>
</span><span class='line'>@state.breweries.each do |brewery|
</span><span class='line'>  if !all_beers_from_brewery(brewery).nil?
</span><span class='line'>    all_beers_from_brewery(brewery).each do |hash|
</span><span class='line'>      brewery.beers.build(name: hash["name"], db_code: hash["id"], abv: hash["abv"], ibu: hash["ibu"], description: hash["description"])
</span><span class='line'>      brewery.save
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<p>The above code uses the brewery ids to find the beers associated with it, and build ActiveRecord associated objects. But it doesn&rsquo;t always work.</p>

<p>Sometimes the breweries will be missing from the database and so when I try to get a json from a missing page, I get a fun exception:</p>

<p>RestClient::ResourceNotFound: 404 Resource Not Found</p>

<p>And my program stops. Since I&rsquo;m iterating through a long list of breweries, this is super annoying, because no subsequent data will be entered into my database. This is where Ruby&rsquo;s catch, throw and ensure methods come in.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>begin
</span><span class='line'>  a + a
</span><span class='line'>rescue =&gt; e
</span><span class='line'>  puts e
</span><span class='line'>ensure
</span><span class='line'>  puts "we'll be fine, regardless of what happens"
</span><span class='line'>end
</span><span class='line'>undefined local variable or method `a' for main:Object
</span><span class='line'>we'll be fine, regardless of what happens
</span></code></pre></td></tr></table></div></figure>


<p>If this code was just written as below, it would break, because a isn&rsquo;t defined.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a + a</span></code></pre></td></tr></table></div></figure>


<p>Using begin, rescue and ensure allows you to negotiate the error and keep moving. It&rsquo;s a little hacky to solve ordinary problems, but when working with large datasets that might fail because of errors in the members of the dataset, it can be super helpful.</p>

<p>The above isn&rsquo;t super different than an if/else statement, except that the error is handled and the code continues. Here&rsquo;s how I use it in real life:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def all_beers_from_brewery(brewery)
</span><span class='line'>  begin
</span><span class='line'>    load_db_json("brewery/#{brewery.db_code}/beers?key=#{@key}")["data"]
</span><span class='line'>  rescue =&gt; error
</span><span class='line'>    retry
</span><span class='line'>    puts "#{error} for #{brewery.name}"
</span><span class='line'>  end
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<p>Now if I get an error iterating through my database with the below code, I don&rsquo;t break the operation, I just get an error message and move on with the parsing:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@state.breweries.each do |brewery|
</span><span class='line'>    all_beers_from_brewery(brewery).each do |hash|
</span><span class='line'>      brewery.beers.build(name: hash["name"], db_code: hash["id"], abv: hash["abv"], ibu: hash["ibu"], description: hash["description"])
</span><span class='line'>      brewery.save
</span><span class='line'>    end
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<p>Javascript and Python have very similar operations. Javascript uses &ldquo;try, throw and catch, finally&rdquo; and Python uses &ldquo;try, except and finally&rdquo;.</p>

<p>Here are some resources to learn more:</p>

<p><a href="http://ruby.bastardsbook.com/chapters/exception-handling/">Ruby Bastards: exception handling</a><br/>
<a href="http://rubylearning.com/satishtalim/ruby_exceptions.html">Ruby Learning: exceptions</a><br/>
<a href="https://blog.newrelic.com/2014/12/10/weird-ruby-2-rescue-interrupt-ensure/">Weird Ruby, rescue and interrupt</a><br/>
<a href="https://rubymonk.com/learning/books/4-ruby-primer-ascent/chapters/41-exceptions/lessons/92-handling">Ruby Monk: handling exceptions</a><br/>
<a href="http://www.jiaaro.com/pythonjavascript-trick-hacky-error-handling/">Exception handling in JS and Python</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Start using Pry!]]></title>
    <link href="http://gosborn.github.io/blog/2015/07/01/start-using-pry/"/>
    <updated>2015-07-01T19:40:56-04:00</updated>
    <id>http://gosborn.github.io/blog/2015/07/01/start-using-pry</id>
    <content type="html"><![CDATA[<h2>Tips for using Pry</h2>

<p><img src="https://camo.githubusercontent.com/c26ae0f28a595b15dc4d135fdcc113366f811853/68747470733a2f2f646c2e64726f70626f782e636f6d2f752f32363532313837352f70727925323073747566662f6c6f676f2f7072795f6c6f676f5f3335302e706e67" alt="pry_image" /></p>

<p>In the past, I&rsquo;ve used REPLs like IRB or <a href="http://repl.it">repl.it</a> to play around with Ruby. Pry adds on tons of functionality and has been my go-to REPL ever since diving into the documentation (on a pretty shallow level, I&rsquo;ll admit). It takes a little bit of getting used to, but just liking learning a manual transmission, it&rsquo;s tough to go back once you get the hang of it.</p>

<p>Below, I&rsquo;ll describe some of my favorite features and some resources for further reading.</p>

<h2>Pry Features</h2>

<p>Pry adds in many features to the REPL environment.</p>

<ul>
<li>You can set <strong>breakpoints</strong> in code with runtime invocation.

<ul>
<li>I won&rsquo;t discuss this as most people are introduced to Pry via this utility to debug code.</li>
</ul>
</li>
<li>You can get <strong>help</strong> on the fly

<ul>
<li><strong>Pry-docs</strong> and source code browsing will eliminate some trips to Google and the Ruby documentation: docs are provided in Pry</li>
<li>Tools are provided to <strong>trace errors</strong></li>
</ul>
</li>
<li>You can easily travel around your code

<ul>
<li>Pry provides tools (not unlike your BASH console) that allow you to <strong>travel in and out of environments</strong> to view local variables and methods</li>
<li>Pry also provides tools that <strong>interact with BASH</strong></li>
<li>Pry also allows you to <strong>travel through time</strong> by replaying your history</li>
</ul>
</li>
<li>Many <strong>plugins</strong> interact with Pry, allowing additional functionality</li>
</ul>


<h3>Moving in and out of environments, in Ruby and BASH</h3>

<p>In pry, cd and ls act in a way similar to the cd and ls commands in BASH. cd allows you to change environments. Below, I used cd to move into the environment of my array. The console tells us this by changing the prompt to include #<Array>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// ♥ pry
</span><span class='line'>[1] pry(main)&gt; arr = Array.new
</span><span class='line'>=&gt; []
</span><span class='line'>[2] pry(main)&gt; cd arr
</span><span class='line'>[3] pry(#&lt;Array&gt;):1&gt; 
</span></code></pre></td></tr></table></div></figure>


<p>Now that I&rsquo;m in an array, I can use ls to see what is available to me.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4] pry(#&lt;Array&gt;):1&gt; ls
</span><span class='line'>Enumerable#methods: 
</span><span class='line'>  all?            each_slice        flat_map  max_by     none?         slice_when
</span><span class='line'>  chunk           each_with_index   grep      member?    one?          sort_by   
</span><span class='line'>  collect_concat  each_with_object  group_by  min        partition   
</span><span class='line'>  detect          entries           inject    min_by     reduce      
</span><span class='line'>  each_cons       find              lazy      minmax     slice_after 
</span><span class='line'>  each_entry      find_all          max       minmax_by  slice_before
</span><span class='line'>Columnize#methods: columnize  columnize_opts  columnize_opts=
</span><span class='line'>Array#methods: 
</span><span class='line'>  &         combination  fill        map!                  reverse!      sort!     
</span><span class='line'>  *         compact      find_index  pack                  reverse_each  sort_by!  
</span><span class='line'>  +         compact!     first       permutation           rindex        take      
</span><span class='line'>  -         concat       flatten     place                 rotate        take_while
</span><span class='line'>  &lt;&lt;        count        flatten!    pop                   rotate!       to_a      
</span><span class='line'>  &lt;=&gt;       cycle        frozen?     pretty_print          sample        to_ary    
</span><span class='line'>  ==        delete       hash        pretty_print_cycle    select        to_h      
</span><span class='line'>  []        delete_at    include?    product               select!       to_s      
</span><span class='line'>  []=       delete_if    index       push                  shelljoin     transpose 
</span><span class='line'>  any?      drop         insert      rassoc                shift         uniq      
</span><span class='line'>  assoc     drop_while   inspect     reject                shuffle       uniq!     
</span><span class='line'>  at        each         join        reject!               shuffle!      unshift   
</span><span class='line'>  bsearch   each_index   keep_if     repeated_combination  size          values_at 
</span><span class='line'>  clear     empty?       last        repeated_permutation  slice         zip       
</span><span class='line'>  collect   eql?         length      replace               slice!        |         
</span><span class='line'>  collect!  fetch        map         reverse               sort        
</span><span class='line'>self.methods: __pry__
</span><span class='line'>locals: _  __  _dir_  _ex_  _file_  _in_  _out_  _pry_</span></code></pre></td></tr></table></div></figure>


<p>ls will show you which methods, constants and variables are accessible to that environment. Use:</p>

<ul>
<li>ls -m; for local methods</li>
<li>ls -l; for local variables</li>
<li>ls -c; for constants</li>
<li>ls -G to search for paramters by name (or partial name)</li>
</ul>


<p>With Pry-docs installed (gem install pry-docs), you can get info on how any method is used. While still in the array environment:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[13] pry(#&lt;Array&gt;):1&gt; ? self.map
</span><span class='line'>
</span><span class='line'>From: array.c (C Method):
</span><span class='line'>Owner: Array
</span><span class='line'>Visibility: public
</span><span class='line'>Signature: map()
</span><span class='line'>Number of lines: 12
</span><span class='line'>
</span><span class='line'>Invokes the given block once for each element of self.
</span><span class='line'>
</span><span class='line'>Creates a new array containing the values returned by the block.
</span><span class='line'>
</span><span class='line'>See also Enumerable#collect.
</span><span class='line'>
</span><span class='line'>If no block is given, an Enumerator is returned instead.
</span><span class='line'>
</span><span class='line'>   a = [ "a", "b", "c", "d" ]
</span><span class='line'>   a.collect { |x| x + "!" }        #=&gt; ["a!", "b!", "c!", "d!"]
</span><span class='line'>   a.map.with_index{ |x, i| x * i } #=&gt; ["", "b", "cc", "ddd"]
</span><span class='line'>   a                                #=&gt; ["a", "b", "c", "d"]</span></code></pre></td></tr></table></div></figure>


<p>Using ? (show-doc is an alias) and .map (using self, an array in this case, as the receiver) returns the Ruby Documentation in the console! No more searching through Google.</p>

<p>Just like in BASH, cd .. goes up an environment, towards main.</p>

<h3>Examples with a method</h3>

<p>Below, I&rsquo;ve created a Dog class, which will return &ldquo;wooooof&rdquo; when bark is called on an instance of the class.</p>

<p>show-source allows the user to look back on the code contained within Dog, very helpful while debugging a larger file, especially while using binding.pry.</p>

<p>Also, observe how one can cd into and instance of the Dog classto see and call its methods.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[17] pry(main)&gt; class Dog
</span><span class='line'>[17] pry(main)*   def bark
</span><span class='line'>[17] pry(main)*     "woooooof"
</span><span class='line'>[17] pry(main)*   end  
</span><span class='line'>[17] pry(main)* end  
</span><span class='line'>=&gt; :bark
</span><span class='line'>[18] pry(main)&gt; doggie = Dog.new
</span><span class='line'>=&gt; #&lt;Dog:0x007fddff9fadc8&gt;
</span><span class='line'>[19] pry(main)&gt; show-source Dog
</span><span class='line'>
</span><span class='line'>From: (pry) @ line 6:
</span><span class='line'>Class name: Dog
</span><span class='line'>Number of lines: 5
</span><span class='line'>
</span><span class='line'>class Dog
</span><span class='line'>  def bark
</span><span class='line'>    "woooooof"
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>[20] pry(main)&gt; cd doggie
</span><span class='line'>[21] pry(#&lt;Dog&gt;):1&gt; bark
</span><span class='line'>=&gt; "woooooof"
</span><span class='line'>[22] pry(#&lt;Dog&gt;):1&gt; ls
</span><span class='line'>Dog#methods: bark
</span><span class='line'>self.methods: __pry__
</span><span class='line'>locals: _  __  _dir_  _ex_  _file_  _in_  _out_  _pry_</span></code></pre></td></tr></table></div></figure>


<h3>BASH manipulation</h3>

<p>Pry can also interact with BASH. Adding . before any BASH command while running pry will allow you to send those commands to BASH. You can switch directories, list content, even cowsay, all easily through Pry.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[36] pry(#&lt;Dog&gt;):1&gt; .cd dev
</span><span class='line'>[37] pry(#&lt;Dog&gt;):1&gt; .pwd
</span><span class='line'>/Users/geo/dev
</span><span class='line'>[38] pry(#&lt;Dog&gt;):1&gt; .cowsay take me home
</span><span class='line'> ______________ 
</span><span class='line'>&lt; take me home &gt;
</span><span class='line'> -------------- 
</span><span class='line'>        \   ^__^
</span><span class='line'>         \  (oo)\_______
</span><span class='line'>            (__)\       )\/\
</span><span class='line'>                ||----w |
</span><span class='line'>                ||     ||
</span><span class='line'>[39] pry(#&lt;Dog&gt;):1&gt; .cd ~
</span><span class='line'>[40] pry(#&lt;Dog&gt;):1&gt; .pwd
</span><span class='line'>/Users/geo
</span><span class='line'>[41] pry(#&lt;Dog&gt;):1&gt; </span></code></pre></td></tr></table></div></figure>


<h3>Tracing errors in code</h3>

<p>Sometimes errors can be a little hard to trace. Here&rsquo;s a convoluted example where the error trickles down through multiple methods.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[10] pry(main)&gt; def gonna_make_error(name)
</span><span class='line'>[10] pry(main)*   name.mistake
</span><span class='line'>[10] pry(main)* end  
</span><span class='line'>=&gt; :gonna_make_error
</span><span class='line'>[11] pry(main)&gt; def second_layer_error(name)
</span><span class='line'>[11] pry(main)*   gonna_make_error(name)
</span><span class='line'>[11] pry(main)* end  
</span><span class='line'>=&gt; :second_layer_error
</span><span class='line'>[12] pry(main)&gt; def third_layer_errof(name)
</span><span class='line'>[12] pry(main)*   second_layer_error(name)
</span><span class='line'>[12] pry(main)* end  
</span><span class='line'>=&gt; :third_layer_errof
</span><span class='line'>[13] pry(main)&gt; third_layer_errof("greg")
</span><span class='line'>NoMethodError: undefined method `mistake' for "greg":String
</span><span class='line'>from (pry):10:in `gonna_make_error'</span></code></pre></td></tr></table></div></figure>


<p>Pry provides two cool tools: wtf? and cat &ndash;ex, to help identify the cause of errors in your code.</p>

<p>wtf? allows you to display a few lines of backtrace for your most recent error.  Not too much different from receiving an error in ruby, but it proves developers have a sense of humor.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[14] pry(main)&gt; wtf?
</span><span class='line'>Exception: NoMethodError: undefined method `mistake' for "greg":String
</span><span class='line'>--
</span><span class='line'>0: (pry):10:in `gonna_make_error'
</span><span class='line'>1: (pry):13:in `second_layer_error'
</span><span class='line'>2: (pry):16:in `third_layer_errof'
</span><span class='line'>3: (pry):18:in `__pry__'
</span><span class='line'>4: /Users/geo/.rvm/gems/ruby-2.2.1/gems/pry-0.10.1/lib/pry/pry_instance.rb:355:in `eval'
</span><span class='line'>5: /Users/geo/.rvm/gems/ruby-2.2.1/gems/pry-0.10.1/lib/pry/pry_instance.rb:355:in `evaluate_ruby'
</span><span class='line'>6: /Users/geo/.rvm/gems/ruby-2.2.1/gems/pry-0.10.1/lib/pry/pry_instance.rb:323:in `handle_line'
</span><span class='line'>7: /Users/geo/.rvm/gems/ruby-2.2.1/gems/pry-0.10.1/lib/pry/pry_instance.rb:243:in `block (2 levels) in eval'
</span><span class='line'>8: /Users/geo/.rvm/gems/ruby-2.2.1/gems/pry-0.10.1/lib/pry/pry_instance.rb:242:in `catch'
</span><span class='line'>9: /Users/geo/.rvm/gems/ruby-2.2.1/gems/pry-0.10.1/lib/pry/pry_instance.rb:242:in `block in eval'</span></code></pre></td></tr></table></div></figure>


<p>cat &ndash;ex allows you to see the actual code that caused the error, which can be really helpful for debugging and learning how to code, especially when navigating errors in sinatra.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[15] pry(main)&gt; cat --ex
</span><span class='line'>
</span><span class='line'>Exception: NoMethodError: undefined method `mistake' for "greg":String
</span><span class='line'>--
</span><span class='line'>From: (pry) @ line 10 @ level: 0 of backtrace (of 32).
</span><span class='line'>
</span><span class='line'>     5: def more_error(name)
</span><span class='line'>     6:   error(name)
</span><span class='line'>     7: end
</span><span class='line'>     8: more_error("greg")
</span><span class='line'>     9: def gonna_make_error(name)
</span><span class='line'> =&gt; 10:   name.mistake
</span><span class='line'>    11: end
</span><span class='line'>    12: def second_layer_error(name)
</span><span class='line'>    13:   gonna_make_error(name)
</span><span class='line'>    14: end
</span><span class='line'>    15: def third_layer_errof(name)
</span><span class='line'>[16] pry(main)&gt; </span></code></pre></td></tr></table></div></figure>


<p>Additionally, hist allows you to see a history of all the commands you&rsquo;ve typed into Pry, to get more information as to how your code has broken.</p>

<h3>Further Resources</h3>

<p>Pry provides a ton more functionality, so I really suggest spending a little time reading the below resources.</p>

<p><a href="http://pryrepl.org/">Pry Home Page</a><br/>
<a href="https://github.com/pry/pry">Pry on Git</a><br/>
<a href="https://github.com/pry/pry/wiki/Available-plugins">Pry Plugins</a><br/>
<a href="http://www.danvisintainer.com/?p=5">PryBaby</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The .zip method]]></title>
    <link href="http://gosborn.github.io/blog/2015/06/18/arranging-arrays/"/>
    <updated>2015-06-18T19:48:54-04:00</updated>
    <id>http://gosborn.github.io/blog/2015/06/18/arranging-arrays</id>
    <content type="html"><![CDATA[<p style="text-align:center;"><img src="http://www.cayzu.com/wp-content/uploads/zipper-1030x360.jpg" title="zipper" alt="zips" /></p>

<p>Uggh, the time I&rsquo;ve wasted trying to google this method.</p>

<p><em>&ldquo;ruby how to add two arrays into one array and have order switch?&rdquo;</em></p>

<p><em>&ldquo;How to combine two arrays in an interwoven fashion? ruby&rdquo;</em></p>

<p><em>&ldquo;how to shuffle two arrays in order and get one back ruby&rdquo;</em></p>

<p><em>etc. etc.</em></p>

<p>Once you remember its name, you have a pretty good idea of what .zip does. But personally, it&rsquo;s tough for me to keep the name in working memory, perhaps because .zip lives all the way at the bottom of the <a href="http://ruby-doc.org/core-2.2.2/Enumerable.html">Ruby Ennumerable documentation</a>.</p>

<p>Maybe .zip is tough to google because it&rsquo;s so much easier to show its functionality than describe it with words.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">array_1</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="o">]</span>
</span><span class='line'><span class="n">array_2</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">]</span>
</span><span class='line'><span class="n">array_1</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">array_2</span><span class="p">)</span> <span class="c1">#=&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [c, &quot;3&quot;]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Calling .zip on an array, while passing in another array as an argument, results in a new array composed of:</p>

<p> <strong>[[array_1[0], array_2[0]],  [array_1[1], array_2[1]],  [array_1[2], array_2_[2]]</strong></p>

<p>The two arrays are now interwoven or shuffled or mixed in order, in a nested array&hellip;I guess zippered is the best terminology here. Even the Ruby documentation is a little vague:</p>

<blockquote><p>Takes one element from enum and merges corresponding elements from each args. This generates a sequence of n-element arrays, where n is one more than the count of arguments.</p></blockquote>

<p>I find myself using .zip from time to time, so its important to remember a couple of things.</p>

<ul>
<li><strong>It returns a nested array.</strong> If 2D isn&rsquo;t your thing, .flatten.</li>
<li><strong>It returns a nested array with elements equal to the length of the first array.</strong>

<ul>
<li>If your second array is longer than the first, those extra values will not be included in the output.</li>
<li>But if it&rsquo;s the other way around, your second array is shorter, you&rsquo;ll get nil values to make up the difference. Example:</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">]</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="o">[</span><span class="mi">101</span><span class="p">,</span><span class="mi">102</span><span class="p">,</span><span class="mi">103</span><span class="p">,</span><span class="mi">104</span><span class="o">]</span>
</span><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1">#=&gt; [[1, 101], [2, 102], [3, 103]] </span>
</span><span class='line'><span class="n">b</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">#=&gt; [[101, 1], [102, 2], [103, 3], [104, nil]] </span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>The .zip function can work on more than two arrays:</strong></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="o">]</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="o">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="o">]</span>
</span><span class='line'><span class="n">c</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="o">]</span>
</span><span class='line'><span class="n">a</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="c1">#=&gt; [[1, 10, &quot;a&quot;], [2, 11, &quot;b&quot;], [3, 12, &quot;c&quot;], [4, 13, &quot;d&quot;]] </span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>.zip can be used to easily create a hash</strong> if your keys and values are in matching arrays:</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">key_array</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;key1&quot;</span><span class="p">,</span> <span class="s2">&quot;key2&quot;</span><span class="p">,</span> <span class="s2">&quot;key3&quot;</span><span class="o">]</span>
</span><span class='line'><span class="n">value_array</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;value1&quot;</span><span class="p">,</span> <span class="s2">&quot;value2&quot;</span><span class="p">,</span> <span class="s2">&quot;value3&quot;</span><span class="o">]</span>
</span><span class='line'><span class="no">Hash</span><span class="o">[</span><span class="n">key_array</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">value_array</span><span class="p">)</span><span class="o">]</span> <span class="c1">#=&gt; {&quot;key1&quot;=&gt;&quot;value1&quot;, &quot;key2&quot;=&gt;&quot;value2&quot;, &quot;key3&quot;=&gt;&quot;value3&quot;} </span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Also, .zip does take a block, but return an unconditional nil.</strong> There was <a href="https://bugs.ruby-lang.org/issues/5044">talk</a> of changing this, or adding a .zip_with feature, to make use of this function a few years back, but was dropped and forgotten about. Unless you are looking to puts to the console, I can&rsquo;t think of a valid way to use this feature.</li>
</ul>


<p>Hopefully, this post will increase .zip awareness: a very useful function, obviously to honor the mighty Akron Zips.</p>

<p style="text-align:center;"><img src="http://assets.sbnation.com/assets/163084/AkronZipsLogo.jpg" title="Akron Zips Logo" alt="zips" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Newbie Developer, Ex-Scientist?]]></title>
    <link href="http://gosborn.github.io/blog/2015/06/08/newbie-developer/"/>
    <updated>2015-06-08T19:34:19-04:00</updated>
    <id>http://gosborn.github.io/blog/2015/06/08/newbie-developer</id>
    <content type="html"><![CDATA[<h2>From biology to coding</h2>

<p>I&rsquo;ve traded in my microscopes for a keyboard. After a number of years pursuing a career in cellular biology, I&rsquo;ve put down the pipettes and decided to really, honestly learn how to write code.</p>

<p>This blog will be about the struggle to learn new computer languages, find out how to use them and life lessons I learn along the way. I won&rsquo;t frequently comment on leaving <a href="http://www.howtoleaveacademia.com/" title="This is a great resource">academia</a>, but my perspective, learning habits and style have all been shaped by that environment.</p>

<p>Jumping out of academia is quite frightening. That universal, cellular process you were an expert on? That&rsquo;s suddenly just as esoteric as astrobiology to most people. Chatting about cell polarity to non-biologists has induced a panic-induced desire to run the nearest research university. Really, what am I left with?</p>

<p>It turns out that studying signal tranduction, gene regulation and mutant phenotypes isn&rsquo;t terribly different from learning how to write, manipulate and refactor code. Evolution has provided our cells with (typically) elegant mechanisms for processing information, communicating data between simple machines and providing feedback on actions. Elegant code (typically) isn&rsquo;t that different. While learning a new coding language is a struggle, it is fun for a biologist to tinker around with: you can think of it like a simple organism.</p>

<h3>Code: not unlike a biological system</h3>

<h4>Looping</h4>

<p>A major principle in gene regulation is the logic behind feedback loops. Understanding how systems respond to, and attenuate, both transient and continuous information is a huge field of research. Below is a cartoon (from Paul Hardin&rsquo;s lab) of a feedback loop in circadian rhythm biology, containing both positive and negative information.</p>

<p><img src="http://www.bio.tamu.edu/USERS/phardin/images/Fig3-InterlockedFBLs.jpg" alt="feedback" /></p>

<p>Pretty complicated, but if you&rsquo;ve ever studied this sort of regulation, or sat through a seminar, you know it&rsquo;s not impossible to sort out.</p>

<p>Code, for some reason, is viewed as magic, or a black box, but it&rsquo;s simpler to figure out than the PERIOD and CLOCK mess above.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def countdown(seconds)  
</span><span class='line'>  while seconds &gt; 0  
</span><span class='line'>    puts "#{seconds} SECOND(S)!"  
</span><span class='line'>    seconds -= 1  
</span><span class='line'>  end  
</span><span class='line'>  "0 left. HAPPY NEW YEAR!"  
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<p>The above Ruby code takes in an argument &ldquo;seconds&rdquo; as a number and counts down in a stepwise fashion. Once it hits zero, it&rsquo;s a happy new year. Code can be simple, understandable, and nowhere near as complex as circadian rhythms.</p>

<h4>The single responsbility principle</h4>

<p>In code, one method should do one thing only. This is called the &ldquo;Single Repsonbility Principle&rdquo;. Programs frequently have a method, called a runner, that runs all the methods. While genes are frequently pleiotropic, they usually act in concert with others to manage cellular activity. What typically unites genes of similar ontologies? Master regulators, which aren&rsquo;t all that unlike runner methods.</p>

<p>Evolution usually favors simplicity. Code does too.</p>

<h4>Breaking it: the phenotypes</h4>

<p>I love to break code. I get the feeling that many of my classmates at the Flatiron School do not feel the same way. Granted, most of the population does not enjoy seeing error messages like the one below.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>countdown.rb:18: syntax error, unexpected end-of-input, expecting keyword_end
</span></code></pre></td></tr></table></div></figure>


<p>
Biologists sometimes spend years trying to introduce mutations into the genomes of model organisms, thereby breaking their systems. The field of biology is principally one that studies what happens when small wrenches are thrown into the inner workings of life. To get to play with systems so quickly, to see what is necessary for structure, what is superfluous or vestigal, and what surprisingly works is really fun. You can get errors back in milliseconds vs years.</p>

<h3>Computer vs. the lab bench</h3>

<p>If you think about systems analytically, biological systems aren&rsquo;t too dissimilar from those written by programmers. The analytically skills biologists acquire can be helpful in understanding all of this. As I continue to learn how to develop, I hope to explore, uncover and share some more similarities.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Post on Octopress]]></title>
    <link href="http://gosborn.github.io/blog/2015/06/02/my-first-post-on-octopress/"/>
    <updated>2015-06-02T09:14:54-04:00</updated>
    <id>http://gosborn.github.io/blog/2015/06/02/my-first-post-on-octopress</id>
    <content type="html"><![CDATA[<p>&ldquo;Hello, world.&rdquo;</p>
]]></content>
  </entry>
  
</feed>
